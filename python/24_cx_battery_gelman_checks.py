#!/usr/bin/env python3
"""
Gelman-style checks for the construction battery.

Computes:
  1) Bootstrap CIs for PR--AUC and ablation deltas (train/test resampling).
  2) Shuffled-label baselines for PR--AUC (train labels permuted).

Inputs:
  - out/cx_battery_candidates.csv
Outputs:
  - out/cx_battery_bootstrap.csv
  - out/cx_battery_bootstrap.tex
  - out/cx_battery_shuffle.csv
  - out/cx_battery_shuffle.tex
"""
from __future__ import annotations

import os
import warnings
from typing import Dict, List, Tuple

import numpy as np
import pandas as pd
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import average_precision_score
from sklearn.exceptions import ConvergenceWarning

IN_PATH = os.path.join("out", "cx_battery_candidates.csv")
OUT_BOOT = os.path.join("out", "cx_battery_bootstrap.csv")
OUT_BOOT_TEX = os.path.join("out", "cx_battery_bootstrap.tex")
OUT_SHUFFLE = os.path.join("out", "cx_battery_shuffle.csv")
OUT_SHUFFLE_TEX = os.path.join("out", "cx_battery_shuffle.tex")

FEATURE_SETS = {
    "full": ["cue1", "cue2", "cue3"],
    "no_cue1": ["cue2", "cue3"],
    "no_cue2": ["cue1", "cue3"],
    "no_cue3": ["cue1", "cue2"],
}

MIN_CANDIDATES = 20
MIN_POSITIVES = 10
N_BOOT = 200
N_SHUFFLE = 200
RNG_SEED = 17


def fit_predict_pr_auc(train: pd.DataFrame, test: pd.DataFrame, features: List[str]) -> float:
    X_tr = train[features].astype(int).values
    y_tr = train["label"].astype(int).values
    X_te = test[features].astype(int).values
    y_te = test["label"].astype(int).values
    if len(np.unique(y_tr)) < 2 or len(np.unique(y_te)) < 2:
        return float("nan")
    clf = LogisticRegression(max_iter=1000, C=1.0)
    with warnings.catch_warnings():
        warnings.filterwarnings("ignore", category=ConvergenceWarning)
        clf.fit(X_tr, y_tr)
    probs = clf.predict_proba(X_te)[:, 1]
    return float(average_precision_score(y_te, probs))


def bootstrap_metrics(train: pd.DataFrame, test: pd.DataFrame, rng: np.random.Generator) -> Dict[str, List[float]]:
    results: Dict[str, List[float]] = {k: [] for k in ["full", "no_cue1", "no_cue2", "no_cue3"]}
    n_tr = len(train)
    n_te = len(test)
    for _ in range(N_BOOT):
        tr_idx = rng.integers(0, n_tr, n_tr)
        te_idx = rng.integers(0, n_te, n_te)
        tr = train.iloc[tr_idx]
        te = test.iloc[te_idx]
        for model, feats in FEATURE_SETS.items():
            pr = fit_predict_pr_auc(tr, te, feats)
            results[model].append(pr)
    return results


def shuffle_baseline(train: pd.DataFrame, test: pd.DataFrame, rng: np.random.Generator) -> List[float]:
    feats = FEATURE_SETS["full"]
    X_tr = train[feats].astype(int).values
    y_tr = train["label"].astype(int).values
    X_te = test[feats].astype(int).values
    y_te = test["label"].astype(int).values
    if len(np.unique(y_tr)) < 2 or len(np.unique(y_te)) < 2:
        return [float("nan")] * N_SHUFFLE
    scores: List[float] = []
    for _ in range(N_SHUFFLE):
        y_perm = rng.permutation(y_tr)
        clf = LogisticRegression(max_iter=1000, C=1.0)
        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=ConvergenceWarning)
            clf.fit(X_tr, y_perm)
        probs = clf.predict_proba(X_te)[:, 1]
        scores.append(float(average_precision_score(y_te, probs)))
    return scores


def ci_bounds(values: List[float]) -> Tuple[float, float, float]:
    arr = np.array([v for v in values if not np.isnan(v)])
    if arr.size == 0:
        return float("nan"), float("nan"), float("nan")
    return float(np.mean(arr)), float(np.percentile(arr, 2.5)), float(np.percentile(arr, 97.5))


def latex_escape(text: str) -> str:
    return text.replace("_", "\\_")


def fmt_float(val: float) -> str:
    if np.isnan(val):
        return "--"
    return f"{val:.3f}"


def write_bootstrap_tex(df: pd.DataFrame) -> None:
    lines = []
    lines.append("% Auto-generated by python/24_cx_battery_gelman_checks.py")
    lines.append("\\begin{table}[t]")
    lines.append("  \\centering")
    lines.append("  \\small")
    lines.append("  \\caption{Bootstrap CIs (2.5/97.5\\%) for construction battery PR--AUC and ablation deltas.}")
    lines.append("  \\label{tab:cx-battery-bootstrap}")
    lines.append("  \\begin{tabular}{l l r r r r r}")
    lines.append("    \\toprule")
    lines.append("    Construction & Direction & PR--AUC (CI) & $\\Delta$C1 (CI) & $\\Delta$C2 (CI) & $\\Delta$C3 (CI) & $B$ \\\\")
    lines.append("    \\midrule")
    for _, row in df.iterrows():
        direction = f"{row['train']}\\ensuremath{{\\to}}{row['test']}"
        construction = latex_escape(str(row["construction"]))
        pr = f"{fmt_float(row['full_mean'])} [{fmt_float(row['full_lo'])}, {fmt_float(row['full_hi'])}]"
        d1 = f"{fmt_float(row['d1_mean'])} [{fmt_float(row['d1_lo'])}, {fmt_float(row['d1_hi'])}]"
        d2 = f"{fmt_float(row['d2_mean'])} [{fmt_float(row['d2_lo'])}, {fmt_float(row['d2_hi'])}]"
        d3 = f"{fmt_float(row['d3_mean'])} [{fmt_float(row['d3_lo'])}, {fmt_float(row['d3_hi'])}]"
        b = int(row["n_valid"]) if not np.isnan(row["n_valid"]) else 0
        lines.append(f"    {construction} & {direction} & {pr} & {d1} & {d2} & {d3} & {b} \\\\")
    lines.append("    \\bottomrule")
    lines.append("  \\end{tabular}")
    lines.append("\\end{table}")
    with open(OUT_BOOT_TEX, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")


def write_shuffle_tex(df: pd.DataFrame) -> None:
    lines = []
    lines.append("% Auto-generated by python/24_cx_battery_gelman_checks.py")
    lines.append("\\begin{table}[t]")
    lines.append("  \\centering")
    lines.append("  \\small")
    lines.append("  \\caption{Shuffled-label PR--AUC baselines for the construction battery.}")
    lines.append("  \\label{tab:cx-battery-shuffle}")
    lines.append("  \\begin{tabular}{l l r r r}")
    lines.append("    \\toprule")
    lines.append("    Construction & Direction & Full PR--AUC & Shuffle mean & Shuffle CI \\\\")
    lines.append("    \\midrule")
    for _, row in df.iterrows():
        direction = f"{row['train']}\\ensuremath{{\\to}}{row['test']}"
        construction = latex_escape(str(row["construction"]))
        full = fmt_float(row["full_pr_auc"])
        mean = fmt_float(row["shuffle_mean"])
        ci = f"[{fmt_float(row['shuffle_lo'])}, {fmt_float(row['shuffle_hi'])}]"
        lines.append(f"    {construction} & {direction} & {full} & {mean} & {ci} \\\\")
    lines.append("    \\bottomrule")
    lines.append("  \\end{tabular}")
    lines.append("\\end{table}")
    with open(OUT_SHUFFLE_TEX, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")


def main() -> None:
    if not os.path.exists(IN_PATH):
        raise FileNotFoundError(IN_PATH)
    df = pd.read_csv(IN_PATH)
    rng = np.random.default_rng(RNG_SEED)

    boot_rows = []
    shuffle_rows = []
    corpora = sorted(df["corpus"].unique())
    constructions = sorted(df["construction"].unique())

    for construction in constructions:
        sub = df[df["construction"] == construction]
        for train_c in corpora:
            for test_c in corpora:
                if train_c == test_c:
                    continue
                train = sub[sub["corpus"] == train_c]
                test = sub[sub["corpus"] == test_c]
                n_train = len(train)
                n_test = len(test)
                pos_train = int(train["label"].sum()) if n_train else 0
                pos_test = int(test["label"].sum()) if n_test else 0
                status = "ok"
                if n_train < MIN_CANDIDATES or n_test < MIN_CANDIDATES or pos_train < MIN_POSITIVES or pos_test < MIN_POSITIVES:
                    status = "not_estimable"
                if status != "ok":
                    continue
                full_pr = fit_predict_pr_auc(train, test, FEATURE_SETS["full"])

                boot = bootstrap_metrics(train, test, rng)
                full_mean, full_lo, full_hi = ci_bounds(boot["full"])
                d1 = [b - a for b, a in zip(boot["full"], boot["no_cue1"]) if not np.isnan(b) and not np.isnan(a)]
                d2 = [b - a for b, a in zip(boot["full"], boot["no_cue2"]) if not np.isnan(b) and not np.isnan(a)]
                d3 = [b - a for b, a in zip(boot["full"], boot["no_cue3"]) if not np.isnan(b) and not np.isnan(a)]
                d1_mean, d1_lo, d1_hi = ci_bounds(d1)
                d2_mean, d2_lo, d2_hi = ci_bounds(d2)
                d3_mean, d3_lo, d3_hi = ci_bounds(d3)
                n_valid = len([v for v in boot["full"] if not np.isnan(v)])

                boot_rows.append({
                    "construction": construction,
                    "train": train_c,
                    "test": test_c,
                    "n_train": n_train,
                    "n_test": n_test,
                    "pos_train": pos_train,
                    "pos_test": pos_test,
                    "full_pr_auc": full_pr,
                    "full_mean": full_mean,
                    "full_lo": full_lo,
                    "full_hi": full_hi,
                    "d1_mean": d1_mean,
                    "d1_lo": d1_lo,
                    "d1_hi": d1_hi,
                    "d2_mean": d2_mean,
                    "d2_lo": d2_lo,
                    "d2_hi": d2_hi,
                    "d3_mean": d3_mean,
                    "d3_lo": d3_lo,
                    "d3_hi": d3_hi,
                    "n_valid": n_valid,
                })

                shuffle_scores = shuffle_baseline(train, test, rng)
                sh_mean, sh_lo, sh_hi = ci_bounds(shuffle_scores)
                shuffle_rows.append({
                    "construction": construction,
                    "train": train_c,
                    "test": test_c,
                    "full_pr_auc": full_pr,
                    "shuffle_mean": sh_mean,
                    "shuffle_lo": sh_lo,
                    "shuffle_hi": sh_hi,
                })

    boot_df = pd.DataFrame(boot_rows).sort_values(["construction", "train", "test"])
    shuffle_df = pd.DataFrame(shuffle_rows).sort_values(["construction", "train", "test"])
    os.makedirs(os.path.dirname(OUT_BOOT), exist_ok=True)
    boot_df.to_csv(OUT_BOOT, index=False)
    shuffle_df.to_csv(OUT_SHUFFLE, index=False)
    write_bootstrap_tex(boot_df)
    write_shuffle_tex(shuffle_df)
    print(f"Wrote {OUT_BOOT}, {OUT_BOOT_TEX}")
    print(f"Wrote {OUT_SHUFFLE}, {OUT_SHUFFLE_TEX}")


if __name__ == "__main__":
    main()
