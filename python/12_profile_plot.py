#!/usr/bin/env python3
"""
Create the cue profile figure for the *let alone* construction.

This script reads the feature table generated by `11_extract_let_alone.py`
and computes per-corpus statistics on parallelism rates, Y-head UPOS
distributions and licensing prevalence.  Bootstrap resampling is used to
estimate 95% confidence intervals.  The resulting figure is saved as
`images/let_alone_profile.pdf` and `images/let_alone_profile.png`.

Usage:

```
python3 src/12_profile_plot.py
```

The script expects to be run from the repository root.
"""

from __future__ import annotations

import os
import sys
from typing import Dict, List, Tuple, Any

import pandas as pd
import numpy as np
import matplotlib
matplotlib.use("Agg")  # use non-interactive backend
import matplotlib.pyplot as plt
import seaborn as sns


RANDOM_SEED = 20250901
BOOTSTRAP_REPS = 1000


def bootstrap_ci(data: np.ndarray, reps: int = BOOTSTRAP_REPS, seed: int = RANDOM_SEED) -> Tuple[float, float, float]:
    """Compute mean and 95% confidence interval via bootstrap.

    Parameters
    ----------
    data: 1D array of numeric values (0/1 for proportions)
    reps: number of bootstrap replicates
    seed: random seed

    Returns
    -------
    (mean, lower_ci, upper_ci)
    """
    rng = np.random.default_rng(seed)
    n = len(data)
    if n == 0:
        return (np.nan, np.nan, np.nan)
    means = np.empty(reps)
    for i in range(reps):
        sample = rng.choice(data, size=n, replace=True)
        means[i] = sample.mean()
    lower = np.percentile(means, 2.5)
    upper = np.percentile(means, 97.5)
    return (data.mean(), lower, upper)


def bootstrap_distribution(df: pd.DataFrame, column: str, categories: List[str], reps: int = BOOTSTRAP_REPS, seed: int = RANDOM_SEED) -> Dict[str, Tuple[float, float, float]]:
    """Compute bootstrap mean and CI for categorical proportions.

    Parameters
    ----------
    df: DataFrame
    column: name of the column containing category labels
    categories: list of categories to consider
    reps: number of replicates
    seed: random seed

    Returns
    -------
    dict mapping category -> (mean, lower, upper)
    """
    rng = np.random.default_rng(seed)
    n = len(df)
    counts = df[column].value_counts().reindex(categories).fillna(0)
    props = counts / n if n > 0 else counts
    # Precompute indices for each category
    indices_by_cat = {cat: df.index[df[column] == cat].tolist() for cat in categories}
    # Bootstrapping
    boot_means: Dict[str, List[float]] = {cat: [] for cat in categories}
    for _ in range(reps):
        sample_idxs = rng.choice(df.index, size=n, replace=True)
        sample = df.loc[sample_idxs, column]
        for cat in categories:
            boot_means[cat].append((sample == cat).mean() if n > 0 else 0.0)
    ci: Dict[str, Tuple[float, float, float]] = {}
    for cat in categories:
        arr = np.array(boot_means[cat])
        ci[cat] = (props[cat], np.percentile(arr, 2.5), np.percentile(arr, 97.5))
    return ci


def main() -> None:
    # Load feature table
    feat_path = os.path.join("out", "let_alone_features.csv")
    df = pd.read_csv(feat_path)
    # Only consider relevant columns
    df["corpus"] = df["corpus"].astype(str)
    corpora = ["gum", "ewt"]
    categories = ["VERB", "NOUN", "ADJ", "OTHER"]
    stats = {}
    # Compute bootstrap stats per corpus
    for corpus in corpora:
        subset = df[df["corpus"] == corpus]
        # Parallelism
        parallel = subset["parallelism"].values.astype(float)
        parallel_mean, parallel_low, parallel_high = bootstrap_ci(parallel)
        # Licensing
        licensing = subset["licensing"].values.astype(float)
        lic_mean, lic_low, lic_high = bootstrap_ci(licensing)
        # Y UPOS distribution
        dist_ci = bootstrap_distribution(subset, "upos_y", categories)
        stats[corpus] = {
            "parallel": (parallel_mean, parallel_low, parallel_high),
            "licensing": (lic_mean, lic_low, lic_high),
            "dist": dist_ci,
            "n": len(subset),
        }
    # Plotting
    sns.set(style="whitegrid")
    fig, axes = plt.subplots(1, 3, figsize=(12, 4), gridspec_kw={'width_ratios': [1, 1.2, 1]})
    # Panel 1: parallelism
    labels = ["GUM", "EWT"]
    means = [stats['gum']['parallel'][0], stats['ewt']['parallel'][0]]
    lows = [stats['gum']['parallel'][1], stats['ewt']['parallel'][1]]
    highs = [stats['gum']['parallel'][2], stats['ewt']['parallel'][2]]
    yerr = [np.array(means) - np.array(lows), np.array(highs) - np.array(means)]
    axes[0].bar(labels, means, yerr=yerr, color=["#4C72B0", "#55A868"], capsize=4)
    axes[0].set_ylim(0, 1)
    axes[0].set_ylabel("Parallelism rate")
    axes[0].set_title("Parallelism")
    # Panel 2: Y-head distribution (stacked bars)
    bottoms = np.zeros(2)
    colors = ["#4C72B0", "#55A868", "#C44E52", "#8172B3"]
    for i, cat in enumerate(categories):
        vals = [stats['gum']['dist'][cat][0], stats['ewt']['dist'][cat][0]]
        axes[1].bar(labels, vals, bottom=bottoms, color=colors[i], label=cat)
        bottoms += vals
    axes[1].set_ylim(0, 1)
    axes[1].set_ylabel("Proportion of Y-heads")
    axes[1].set_title("Distribution of Y-head UPOS")
    axes[1].legend(title="UPOS", bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)
    # Panel 3: licensing
    lic_means = [stats['gum']['licensing'][0], stats['ewt']['licensing'][0]]
    lic_lows = [stats['gum']['licensing'][1], stats['ewt']['licensing'][1]]
    lic_highs = [stats['gum']['licensing'][2], stats['ewt']['licensing'][2]]
    lic_yerr = [np.array(lic_means) - np.array(lic_lows), np.array(lic_highs) - np.array(lic_means)]
    axes[2].bar(labels, lic_means, yerr=lic_yerr, color=["#4C72B0", "#55A868"], capsize=4)
    axes[2].set_ylim(0, 1)
    axes[2].set_ylabel("Licensing prevalence")
    axes[2].set_title("Licensing")
    # Add sample size annotations
    for i, corpus in enumerate(["gum", "ewt"]):
        n = stats[corpus]['n']
        axes[0].text(i, means[i] + 0.03, f"N={n}", ha='center', va='bottom', fontsize=8)
    plt.tight_layout()
    # Save figures
    os.makedirs("images", exist_ok=True)
    fig_path_pdf = os.path.join("images", "let_alone_profile.pdf")
    fig_path_png = os.path.join("images", "let_alone_profile.png")
    fig.savefig(fig_path_pdf)
    fig.savefig(fig_path_png, dpi=300)
    print(f"Saved profile figure to {fig_path_pdf} and {fig_path_png}")


if __name__ == "__main__":
    main()